package app.bicintime.wolf.bicintimeactivities;

import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;

import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.android.gms.maps.model.Polyline;
import com.google.android.gms.maps.model.PolylineOptions;

import java.util.ArrayList;

//this class will show our map with the route generated by the parameters set by the user.
//it implements onMapReadyCallBack, needed to be able to display a googleMap.
public class RouteMapActivity extends BaseActivity implements OnMapReadyCallback {

    private static final String LOG_DLOAD = "LOGDOWNLOAD";
    private static final String FRAGMENT_KEY = "test";
    private GoogleMap googleMap; //our googlemap reference
    private static final String DEFAULT = "Default text";
    String startLocation, endLocation, loudiness, lanes, timeSelected;


    //this variable is useful to store the steps generated by Google Map Directions API.
    ArrayList<Steps> stepsArrayList = new ArrayList<>();

    private static final String LOG_MAP = "LOGMAP";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_route_map);

        agregarToolbar();
        setUpDrawer();
        getSharedPreferencesData();


        // GetMapDirectionsJsonData getMapDirectionsJsonData = new GetMapDirectionsJsonData(startLocation,endLocation,timeSelected);
        //stepsArrayList = getMapDirectionsJsonData.getSteps();
        //Log.d(LOG_DLOAD, "stepsArrayList size on constructor is: " + stepsArrayList.size());
        //getMapDirectionsJsonData.execute();

        //these two steps are needed to display our google maps on our screen.
        SupportMapFragment supportMapFragment = (SupportMapFragment) this.getSupportFragmentManager().findFragmentById(R.id.mapFragment);
        supportMapFragment.getMapAsync(this);//This method will call our onMapReady (inherited method from our interface).

    }

    //On this method we will retrieve the information passed through previous screens as planroute and select time screens.
    private void getSharedPreferencesData() {

        SharedPreferences sharedPreferences = getSharedPreferences("MyData", MODE_PRIVATE);
        startLocation = sharedPreferences.getString("startLocationToRoute", DEFAULT);
        endLocation = sharedPreferences.getString("endLocationToRoute", DEFAULT);
        loudiness = sharedPreferences.getString("loudinessToRoute", DEFAULT);
        lanes = sharedPreferences.getString("lanesToRoute", DEFAULT);
        timeSelected = sharedPreferences.getString("timeToRoute", DEFAULT);


        Log.d(LOG_DLOAD, "Im getting the next data (RouteActivity): " + startLocation + "\n" + endLocation + "\n" + loudiness + "\n" + lanes + "\n" + timeSelected);

        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.clear();
        editor.commit();
    }

    //This will be called to get our map display to java object code reference??
    @Override
    public void onMapReady(GoogleMap googleMap) {

        Log.d(LOG_DLOAD, "onMapReady called");


        this.googleMap = googleMap;


        googleMap.setMyLocationEnabled(true);

        double latitude = 41.372203;
        double longitude = 2.180496;

        final LatLng WTC = new LatLng(41.372203, 2.180496);

        double latitude_array[] = {41.401845, 41.395149, 41.398755, 41.388452};
        double longitude_array[] = {2.181116, 2.171503, 2.195879, 2.196050};


        MarkerOptions markerOptions[];

        ArrayList<MarkerOptions> markers = new ArrayList<MarkerOptions>();


        for (int i = 0; i < latitude_array.length; i++) {

            markers.add(new MarkerOptions().position(
                    new LatLng(latitude_array[i], longitude_array[i])).title("Hello Maps"));

            markers.get(i).icon(BitmapDescriptorFactory
                    .defaultMarker(BitmapDescriptorFactory.HUE_ROSE));

            googleMap.addMarker(markers.get(i));


        }


        CameraPosition cameraPosition = new CameraPosition.Builder()
                .target(new LatLng(latitude, longitude)).zoom(12).build();
        googleMap.animateCamera(CameraUpdateFactory
                .newCameraPosition(cameraPosition));

        Log.d(LOG_DLOAD, "stepsArrayList inside onMapRady size is: " + stepsArrayList.size());


    }

    @Override
    public void onBackPressed() {

        Intent intent = new Intent(this, PlanSelectTimeActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
        startActivity(intent);

    }


    //We call our thread from the onResume
    //the steps are: OnCreate -> OnResume -> onMapReady -> onPostExecute
    @Override
    protected void onResume() {
        super.onResume();

        ProcessSteps processSteps = new ProcessSteps(startLocation, endLocation, timeSelected);
        processSteps.execute();


    }

    //this class reuse the funcionality of other class with thread inside.
    public class ProcessSteps extends GetMapDirectionsJsonData {

        //constructor
        public ProcessSteps(String origin, String destination, String time) {
            super(origin, destination, time);

        }

        public void execute() {
            //super.execute();
            ProcessData processData = new ProcessData();
            processData.execute();
        }

        //this thread will reuse the funcionality of other threads.
        //it is responsible for storing the data and having it available on the map screen for now.
        public class ProcessData extends DownloadJsonData {

            protected void onPostExecute(String webData) {
                super.onPostExecute(webData);

                Log.d(LOG_DLOAD, "onPostExecute of processData called");

                //here i should fill the arraylist
                stepsArrayList = getSteps();
                Log.d(LOG_DLOAD, "Size of array onPostExecute ProcessData is: " + stepsArrayList.size());
                //now it's working

                ArrayList<MarkerOptions> markers = new ArrayList<MarkerOptions>();

                //calling this on Post execute, is right?
                for (int i = 0; i < stepsArrayList.size(); i++) {

                    Log.d(LOG_DLOAD, "Object in arrayList is: " + stepsArrayList.get(i).toString());
                    Polyline line = googleMap.addPolyline(new PolylineOptions()
                            .add(stepsArrayList.get(i).getStartLocationStep(), stepsArrayList.get(i).getEndLocationStep())
                            .width(5)
                            .color(Color.RED));

                    // for debugging purposes: draw a marker at the end of each step
                    // googleMap.addMarker(new MarkerOptions().position(new LatLng(stepsArrayList.get(i).getStartLocationStep().latitude, stepsArrayList.get(i).getStartLocationStep().longitude)));

                }

            }
        }

    }

}
