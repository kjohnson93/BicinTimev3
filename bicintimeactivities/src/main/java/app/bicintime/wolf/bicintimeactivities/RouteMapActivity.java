package app.bicintime.wolf.bicintimeactivities;

import android.app.ProgressDialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;

import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.CameraPosition;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.android.gms.maps.model.Polyline;
import com.google.android.gms.maps.model.PolylineOptions;

import java.util.ArrayList;

//this class will show our map with the route generated by the parameters set by the user.
//it implements onMapReadyCallBack, needed to be able to display a googleMap.
public class RouteMapActivity extends BaseActivity implements OnMapReadyCallback {

    private static final String LOG_DLOAD = "LOGDOWNLOAD";
    private static final String FRAGMENT_KEY = "test";
    private static final String LOG_POINTS = "LOGPOINTS";
    private static final String LOG_PROGRESS = "LOGPROGRESS";
    private GoogleMap googleMap; //our googlemap reference
    private static final String DEFAULT = "Default text";
    String startLocation, endLocation, loudiness, lanes, timeSelected;
    private ArrayList<LatLng> pointsRouteArrayList = new ArrayList<>();

    private int indexWpStart, indexWpArrive;

    ProgressDialog progressDialog;


    //this variable is useful to store the steps generated by Google Map Directions API.
    ArrayList<Steps> stepsArrayList = new ArrayList<>();
    ArrayList<Waypoints> waypointsArrayList = new ArrayList<>();

    private static final String LOG_MAP = "LOGMAP";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_route_map);

        agregarToolbar();
        setUpDrawer();
        getSharedPreferencesData();


        // GetMapDirectionsJsonData getMapDirectionsJsonData = new GetMapDirectionsJsonData(startLocation,endLocation,timeSelected);
        //stepsArrayList = getMapDirectionsJsonData.getSteps();
        //Log.d(LOG_DLOAD, "stepsArrayList size on constructor is: " + stepsArrayList.size());
        //getMapDirectionsJsonData.execute();

        //these two steps are needed to display our google maps on our screen.
        SupportMapFragment supportMapFragment = (SupportMapFragment) this.getSupportFragmentManager().findFragmentById(R.id.mapFragment);
        supportMapFragment.getMapAsync(this);//This method will call our onMapReady (inherited method from our interface).

    }

    //On this method we will retrieve the information passed through previous screens as planroute and select time screens.
    private void getSharedPreferencesData() {

        SharedPreferences sharedPreferences = getSharedPreferences("MyData", MODE_PRIVATE);
        startLocation = sharedPreferences.getString("startLocationToRoute", DEFAULT);
        endLocation = sharedPreferences.getString("endLocationToRoute", DEFAULT);
        loudiness = sharedPreferences.getString("loudinessToRoute", DEFAULT);
        lanes = sharedPreferences.getString("lanesToRoute", DEFAULT);
        timeSelected = sharedPreferences.getString("timeToRoute", DEFAULT);


        Log.d(LOG_DLOAD, "Im getting the next data (RouteActivity): " + startLocation + "\n" + endLocation + "\n" + loudiness + "\n" + lanes + "\n" + timeSelected);

        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.clear();
        editor.commit();
    }

    //This will be called to get our map display to java object code reference??
    @Override
    public void onMapReady(GoogleMap googleMap) {

        Log.d(LOG_DLOAD, "onMapReady called");


        this.googleMap = googleMap;


        googleMap.setMyLocationEnabled(true);

        double latitude = 41.372203;
        double longitude = 2.180496;

        final LatLng WTC = new LatLng(41.372203, 2.180496);

        double latitude_array[] = {41.401845, 41.395149, 41.398755, 41.388452};
        double longitude_array[] = {2.181116, 2.171503, 2.195879, 2.196050};


        MarkerOptions markerOptions[];

        ArrayList<MarkerOptions> markers = new ArrayList<MarkerOptions>();


        for (int i = 0; i < latitude_array.length; i++) {

            markers.add(new MarkerOptions().position(
                    new LatLng(latitude_array[i], longitude_array[i])).title("Hello Maps"));

            markers.get(i).icon(BitmapDescriptorFactory
                    .defaultMarker(BitmapDescriptorFactory.HUE_ROSE));

            googleMap.addMarker(markers.get(i));


        }


        CameraPosition cameraPosition = new CameraPosition.Builder()
                .target(new LatLng(latitude, longitude)).zoom(12).build();
        googleMap.animateCamera(CameraUpdateFactory
                .newCameraPosition(cameraPosition));

        Log.d(LOG_DLOAD, "stepsArrayList inside onMapRady size is: " + stepsArrayList.size());


    }

    @Override
    public void onBackPressed() {

        SharedPreferences sharedPreferences = getSharedPreferences("MyData", MODE_PRIVATE);
        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString("startLocationToSelectTime", startLocation);
        editor.putString("endLocationToSelectTime", endLocation);
        editor.putString("loudinessToSelectTime", loudiness);
        editor.putString("lanesToSelectTim", lanes);
       // editor.putString("timeToRoute", timeSelected); //I think it may be not needed..
        editor.commit();

        Intent intent = new Intent(this, PlanSelectTimeActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
        startActivity(intent);

    }


    //We call our thread from the onResume
    //the steps are: OnCreate -> OnResume -> onMapReady -> onPostExecute
    @Override
    protected void onResume() {
        super.onResume();

        //ProcessSteps processSteps = new ProcessSteps(startLocation, endLocation, timeSelected);
        //processSteps.execute();
        Log.d(LOG_MAP, "Testng what are the coordinates:" + startLocation + "\n" + endLocation + "\n" + timeSelected);
        ProcessWaypoints processWaypoints = new ProcessWaypoints(startLocation, endLocation, timeSelected);
        processWaypoints.execute();


    }

    public class ProcessWaypoints extends GetBicinTimeJsonData {

        public ProcessWaypoints(String origin, String destination, String time) {
            super(origin, destination, time);


        }

        public void execute() {

            DownloadData downloadData = new DownloadData();
            Log.d(LOG_PROGRESS, "OnPreExecute called from execute ProcessWaypoints");
            downloadData.execute();
        }

        public class DownloadData extends DownloadJsonData {

            @Override
            protected void onPreExecute() {
                super.onPreExecute();
                Log.d(LOG_PROGRESS, "OnPreExecute called from ProcessWaypoints");


                progressDialog = ProgressDialog.show(RouteMapActivity.this, "Please, Wait", "Wait...", true);
            }

            @Override
            protected void onPostExecute(String result) {
                super.onPostExecute(result);

                waypointsArrayList = getWaypointsArrayList();

                Waypoints waypoint1 = waypointsArrayList.get(0); //station subida
                Waypoints waypoint2 = waypointsArrayList.get(1); //station bajada

                Log.d(LOG_DLOAD, "Size of waypoints array inside thread is: " + waypointsArrayList.size());

                ProcessSteps processSteps = new ProcessSteps(startLocation, endLocation, waypoint1, waypoint2);
                processSteps.execute();

            }

            @Override
            protected String doInBackground(String... params) {
                return super.doInBackground(params);
            }
        }
    }

    //this class reuse the funcionality of other class with thread inside.
    public class ProcessSteps extends GetMapDirectionsJsonData {

        //constructor
        public ProcessSteps(String origin, String destination, Waypoints waypointStart, Waypoints waypointEnd) {
            super(origin, destination, waypointStart, waypointEnd);

        }

        public void execute() {
            //super.execute();
            ProcessData processData = new ProcessData();
            processData.execute();
        }

        //this thread will reuse the funcionality of other threads.
        //it is responsible for storing the data and having it available on the map screen for now.
        public class ProcessData extends DownloadJsonData {

            @Override
            protected void onPreExecute() {
                super.onPreExecute();
                Log.d(LOG_PROGRESS, "OnPreExecute called from ProcessWaySteps");
            }

            protected void onPostExecute(String webData) {
                super.onPostExecute(webData);

                Log.d(LOG_DLOAD, "onPostExecute of processData called");

                //here i should fill the arraylist
                //stepsArrayList = getSteps();

                //Here we obtain the latlong array
                pointsRouteArrayList = getPointsRouteArrayList();

                indexWpStart = getIndexWpStart();
                indexWpArrive = getIndexWpArrive();

                //ArrayList<MarkerOptions> markers = new ArrayList<MarkerOptions>();

          /*      //calling this on Post execute, is right?
                for (int i = 0; i < stepsArrayList.size(); i++) {

                    Log.d(LOG_DLOAD, "Object in arrayList is: " + stepsArrayList.get(i).toString());
                    Polyline line = googleMap.addPolyline(new PolylineOptions()
                            .add(stepsArrayList.get(i).getStartLocationStep(), stepsArrayList.get(i).getEndLocationStep())
                            .width(5)
                            .color(Color.RED));

                    // for debugging purposes: draw a marker at the end of each step
                    // googleMap.addMarker(new MarkerOptions().position(new LatLng(stepsArrayList.get(i).getStartLocationStep().latitude, stepsArrayList.get(i).getStartLocationStep().longitude)));

                }
*/
                drawRoute(indexWpStart, indexWpArrive, pointsRouteArrayList);
        /*        //TODO Now we draw this way, but it has to be modified to draw the right segments of the route (walking, bicyling and walking again).
                for (int i = 0; i < pointsRouteArrayList.size() - 1; i++) {


                    Polyline polyline = googleMap.addPolyline(new PolylineOptions().add(pointsRouteArrayList.get(i), pointsRouteArrayList.get(i + 1)).width(5).color(Color.RED));

                    // for debugging purposes: draw a marker at the end of each step
                    // googleMap.addMarker(new MarkerOptions().position(new LatLng(stepsArrayList.get(i).getStartLocationStep().latitude, stepsArrayList.get(i).getStartLocationStep().longitude)));
                }*/

            }

            //Draw the three sections of the route.
            private void drawRoute(int indexWpStart, int indexWpArrive, ArrayList<LatLng> pointsRouteArrayList) {

                Log.d(LOG_POINTS, "Size of index Start Bicycle: " + indexWpStart);
                Log.d(LOG_POINTS, "Size of index Arrive Bicycle: " + indexWpArrive);
                Log.d(LOG_POINTS, "Size of pointsRouteArrayList" + pointsRouteArrayList.size());
                Log.d(LOG_PROGRESS, "asdsadsadsadas");

                for (int i = 0; i < indexWpStart; i++) {
                    Polyline polyLine = googleMap.addPolyline(new PolylineOptions().add(pointsRouteArrayList.get(i), pointsRouteArrayList.get(i + 1)).width(5).color(Color.GREEN));
                }

                for (int i = indexWpStart; i < indexWpArrive; i++) {
                    Polyline polyLine = googleMap.addPolyline(new PolylineOptions().add(pointsRouteArrayList.get(i), pointsRouteArrayList.get(i + 1)).width(5).color(Color.RED));
                }

                for (int i = indexWpArrive; i < pointsRouteArrayList.size() - 1; i++) {

                    Polyline polyLine = googleMap.addPolyline(new PolylineOptions().add(pointsRouteArrayList.get(i), pointsRouteArrayList.get(i + 1)).width(5).color(Color.GREEN));
                }

                progressDialog.dismiss();

            }
        }

    }

}
